import sys
from PyQt5 import QtWidgets, QtCore
import main_window
import edit_window

import subprocess
from pathlib import Path

HOME = str(Path.home())
CONFIG_LOCATION = HOME + '/.config/libinput-gestures.conf'

actions_mapping = {
    'Swipe Up': 'gesture swipe up',
    'Swipe Down': 'gesture swipe down',
    'Swipe Left': 'gesture swipe left',
    'Swipe LeftUp': 'gesture swipe left_up',
    'Swipe LeftDown': 'gesture swipe  left_down',
    'Swipe Right': 'gesture swipe right',
    'Swipe RightUp': 'gesture swipe right_up',
    'Swipe RightDown': 'gesture swipe right_down',
    'Pinch In': 'gesture pinch in',
    'Pinch Out': 'gesture pinch out',
    'Pinch Clockwise': 'gesture pinch clockwise',
    'Pinch Anticlockwise': 'gesture pinch anticlockwise',
}

reversed_mapping = {
    'gesture swipe up': 'Swipe Up',
    'gesture swipe down': 'Swipe Down',
    'gesture swipe left': 'Swipe Left',
    'gesture swipe left_up': 'Swipe LeftUp',
    'gesture swipe  left_down': 'Swipe LeftDown',
    'gesture swipe right': 'Swipe Right',
    'gesture swipe right_up': 'Swipe RightUp',
    'gesture swipe right_down': 'Swipe RightDown',
    'gesture pinch in': 'Pinch In',
    'gesture pinch out': 'Pinch Out',
    'gesture pinch clockwise': 'Pinch Clockwise',
    'gesture pinch anticlockwise': 'Pinch Anticlockwise'
}

keys_mapping = {
    'meta': 'super',
    'pgdown': 'Page_Down',
    'pgup': 'Page_Up',
    'right': 'Right',
    'left': 'Left',
    'up': 'Up',
    'down': 'Down',
    'f1': 'F1',
    'f2': 'F2',
    'f3': 'F3',
    'f4': 'F4',
    'f5': 'F5',
    'f6': 'F6',
    'f7': 'F7',
    'f8': 'F8',
    'f9': 'F9',
    'f10': 'F10',
    'f11': 'F11',
    'f12': 'F12',
}

def read_config():
    try:
        with open(CONFIG_LOCATION, 'r') as config:
            conf = config.readlines()
        return conf
    except FileNotFoundError:
        return ''


def write_config(new_conf):
    with open(CONFIG_LOCATION, 'w') as config:
        config.write(''.join(new_conf))


def fix_config():
    conf = read_config()
    fixed_conf = []
    for line in conf:
        if line.startswith('#'):
            fixed_conf.append(line)
        else:
            splitted = line.replace('\t', ' ').split()
            if splitted[0] in ['gesture', 'device', 'swipe_threshold']:
                if splitted[0] == 'gesture':
                    if splitted[4] == 'xdotool':
                        if splitted[5] == 'key' and len(splitted) == 7:
                            fixed_conf.append(line)
                    else:
                        fixed_conf.append(line)
                else:
                    if len(splitted) == 2:
                        fixed_conf.append(line)
    write_config(''.join(fixed_conf))
                


def find_key_combo(qt_key_combo):
    """Key combo translator
    
    Takes string with QT-like key combo (generated by PyQt5.QtWidgets.QKeySequenceEdit)
    mapes into a string consumable by xdotool
    """
    xdotool_key_combo = []
    for qt_key in qt_key_combo.split('+'):
        lowered_key = qt_key.lower()
        if lowered_key in keys_mapping:
            xdotool_key_combo.append(keys_mapping[lowered_key])
        else:
            xdotool_key_combo.append(lowered_key)
    return '+'.join(xdotool_key_combo)
#print(find_key_combo('Alt+Meta+A+Right'))

class GesturesApp(QtWidgets.QMainWindow, main_window.Ui_MainWindow):
    def __init__(self, parent=None):
        super().__init__()
        self.setupUi(self)
        self.setWindowTitle('Libinput Gestures Qt')

        self.display_config()

        self.adding = EditGestures()
        self.adding.setWindowModality(QtCore.Qt.WindowModal)

        self.actionAdd.triggered.connect(self.start_adding)
        self.actionRefresh.triggered.connect(self.refresh)
        
        self.actionStatus.triggered.connect(self.display_status)
        self.actionRestart.triggered.connect(self.restart_utility)
        self.actionStop.triggered.connect(self.stop_utility)
        self.actionStart.triggered.connect(self.start_utility)

        self.pushButton.clicked.connect(self.start_adding)

        try:
            subprocess.run(['libinput-gestures-setup', 'status'])
            self.installed = True
        except FileNotFoundError:
            QtWidgets.QMessageBox.about(self, "Problem", "Cannot find libinput-gestures. Are you sure it is installed correctly?")
            self.installed = False

    def start_adding(self):
        self.adding.show()

    def refresh(self):
        self.display_config(refresh=True)
    
    def display_status(self):
        if self.installed:
            status = subprocess.run(['libinput-gestures-setup', 'status'], capture_output=True)
            status = status.stdout.decode('utf-8')
            installed = 'no'
            if 'is installed' in status:
                installed = 'yes'
            running = 'no'
            if 'is running' in status:
                running = 'yes'
            set_to_autostart = 'no'
            if 'is set to autostart' in status:
                set_to_autostart = 'yes'
            status = 'Installed: {}\nRunning: {}\nAutostart: {}\n'.format(installed, running, set_to_autostart)
            QtWidgets.QMessageBox.about(self, "Status", status)
    
    def restart_utility(self):
        if self.installed:
            status = subprocess.run(['libinput-gestures-setup', 'restart'], capture_output=True)
            status = status.stdout.decode('utf-8')
            QtWidgets.QMessageBox.about(self, "Status", status)
    
    def stop_utility(self):
        if self.installed:
            status = subprocess.run(['libinput-gestures-setup', 'stop'], capture_output=True)
            status = status.stdout.decode('utf-8')
            QtWidgets.QMessageBox.about(self, "Status", status)
    
    def start_utility(self):
        if self.installed:
            status = subprocess.run(['libinput-gestures-setup', 'start'], capture_output=True)
            status = status.stdout.decode('utf-8')
            QtWidgets.QMessageBox.about(self, "Status", status)
    
    def prepare_config_for_displaying(self):
        conf = read_config()
        self.gestures = []
        self.fingers = []
        self.shortcuts = []
        self.buttons = []
        self.actions = []
        for line in conf:
            if line.startswith('gesture'):
                splitted = line.replace('\t', ' ').split()
                action = '{} {} {}'.format(splitted[0], splitted[1], splitted[2])
                self.gestures.append(QtWidgets.QLabel(reversed_mapping['{} {} {}'.format(splitted[0], splitted[1], splitted[2])]))
                self.fingers.append(QtWidgets.QLabel(splitted[3]))
                if splitted[4] == 'xdotool' and splitted[5] == 'key':
                    self.actions.append(QtWidgets.QLabel('shortcut'))
                    self.shortcuts.append(QtWidgets.QLabel(splitted[6]))
                else:
                    self.actions.append(QtWidgets.QLabel('command'))
                    self.shortcuts.append(QtWidgets.QLabel(' '.join(splitted[4:])))
                self.buttons.append(action)

    def display_config(self, refresh=False):
        if refresh:
            self.area.deleteLater()
        
        try:
            self.prepare_config_for_displaying()
        except Exception:
            reply = QtWidgets.QMessageBox.question(
                self, 'Problem',
                "Something is wrong with the configuration file...\nFix it?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                QtWidgets.QMessageBox.No
            )
            if reply == QtWidgets.QMessageBox.Yes:
                fix_config()
                self.prepare_config_for_displaying()
            else:
                sys.exit()
        
        self.layout = self.verticalLayout
        self.area = QtWidgets.QScrollArea()
        content_widget = QtWidgets.QWidget()
        self.area.setWidget(content_widget)
        flay = QtWidgets.QGridLayout(content_widget)
        self.area.setWidgetResizable(True)

        for i, label in enumerate(self.gestures):
            flay.addWidget(label, i, 0)

        for i, label in enumerate(self.fingers):
            flay.addWidget(label, i, 1)

        for i, label in enumerate(self.actions):
            flay.addWidget(label, i, 2)

        for i, label in enumerate(self.shortcuts):
            flay.addWidget(label, i, 3)

        for i, button in enumerate(self.buttons):
            deleteButton = QtWidgets.QPushButton("Delete")
            deleteButton.setAccessibleName(button)
            deleteButton.clicked.connect(self.delete_entry)
            flay.addWidget(deleteButton, i, 4)

        self.layout.addWidget(self.area)

    def delete_entry(self):
        button = self.sender()
        if isinstance(button, QtWidgets.QPushButton):
            reply = QtWidgets.QMessageBox.question(
                self, 'Message',
                "Are you sure to delete?",
                QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                QtWidgets.QMessageBox.No
            )
            if reply == QtWidgets.QMessageBox.Yes:
                conf = read_config()
                new_conf = [line for line in conf if not line.startswith(button.accessibleName())]
                write_config(new_conf)
                self.display_config(refresh=True)

        
        
class EditGestures(QtWidgets.QWidget, edit_window.Ui_Form):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.setWindowTitle('Add Gestures')

        self.action = ''
        self.fingers = 0
        self.shortcut = ''
        
        self.fingersLine.setMinimum(2)

        self.draw_shortcut()
        self.shortcut_command.activated[str].connect(self.shortcut_or_command)
        
        self.actionMenu.activated[str].connect(self.action_chosen)
        self.fingersLine.valueChanged[int].connect(self.fingers_chosen)
        self.saveButton.clicked.connect(self.save_changes)

    def shortcut_or_command(self, text):
        if text == 'Keyboard Shortcut':
            self.draw_shortcut()
        else:
            self.draw_command()

    def draw_shortcut(self):
        self.actionType.setText('Keyboard Shortcut')
        self.keyboardLine = QtWidgets.QKeySequenceEdit()
        self.gridLayout.addWidget(self.keyboardLine, 4, 2)
        self.keyboardLine.keySequenceChanged.connect(self.shortcut_chosen)
        
    def draw_command(self):
        self.actionType.setText('Command')
        self.commandLine = QtWidgets.QLineEdit()
        self.gridLayout.addWidget(self.commandLine, 4, 2)
        self.commandLine.textChanged[str].connect(self.command_chosen)

    def action_chosen(self, text):
        self.action = actions_mapping[text]

    def fingers_chosen(self, value):
        self.fingers = value

    def shortcut_chosen(self, text):
        self.shortcut = 'xdotool key ' + find_key_combo(text.toString())

    def command_chosen(self, text):
        self.shortcut = text

    def save_changes(self):
        if self.action and self.fingers and self.shortcut:
            conf = read_config()
            new_conf = []
            for line in conf:
                if not line.startswith(self.action):
                    new_conf.append(line)
            new_conf.append('{}\t{} {}\n'.format(self.action, str(self.fingers), self.shortcut))
            write_config(new_conf)
            self.actionMenu.setCurrentIndex(0)
            self.fingersLine.setValue(0)
            #self.keyboardLine.setText('')
            QtWidgets.QMessageBox.about(self, "Success", "Cofiguration successfully edited.")
            self.close()
        else:
            QtWidgets.QMessageBox.about(self, "Fail", "Please, fill all the forms.")


def main():
    app = QtWidgets.QApplication(sys.argv)
    window = GesturesApp()
    window.show()
    app.exec_()

if __name__ == '__main__':
    main()
